# ğŸŒŠ Streams
---

## âœ¨ What are Streams?

> **Streams** were introduced in **Java 8** to process collections of data in a **functional, declarative, and efficient** way.

### Why Streams?

* Simplify data processing
* Avoid manual loops
* Support parallel execution
* Encourage clean & readable code

### Stream Pipeline

Every stream works in **three stages**:

1. **Source** â€“ where the data comes from
2. **Intermediate operations** â€“ transform the stream
3. **Terminal operation** â€“ triggers execution

```
Source â†’ Intermediate Ops â†’ Terminal Op
```

---

## ğŸ— Creating Streams

```java
List<Integer> numbers = Arrays.asList(1,2,3,4,7,2);
```

### 1ï¸âƒ£ From Collections

```java
Stream<Integer> stream1 = numbers.stream();
```

### 2ï¸âƒ£ From Arrays

```java
String[] array = {"a", "b", "c"};
Stream<String> stream2 = Arrays.stream(array);
```

### 3ï¸âƒ£ Using Stream.of()

```java
Stream<String> stream3 = Stream.of("a", "b", "c");
```

### 4ï¸âƒ£ Infinite Streams

```java
Stream.generate(() -> 1).limit(20);

List<Integer> collect = Stream.iterate(1, x -> x + 1)
        .limit(100)
        .collect(Collectors.toList());
```

---

## ğŸ”„ Intermediate Operations

> Intermediate operations **return a new stream** and are **lazy** â€” they execute **only when a terminal operation is called**.

```java
List<String> list = Arrays.asList("Akshit","Ram","Shyam","Ghanshyam","Akshit");
```

---

### 1ï¸âƒ£ filter()

> Filters elements based on a condition

```java
Stream<String> filteredStream = list.stream()
        .filter(x -> x.toLowerCase().startsWith("a"));

System.out.println(filteredStream.count());
```

---

### 2ï¸âƒ£ map()

> Transforms each element

```java
list.stream().map(String::toUpperCase);
```

---

### 3ï¸âƒ£ sorted()

```java
Stream<String> sortedStream = list.stream().sorted();

Stream<String> sortedStream2 = list.stream()
        .sorted((a, b) -> a.length() - b.length());
```

---

### 4ï¸âƒ£ distinct()

> Removes duplicate elements (stateful operation)

```java
System.out.println(
    list.stream()
        .filter(x -> x.startsWith("A"))
        .distinct()
        .count()
);
```

---

### 5ï¸âƒ£ limit()

```java
System.out.println(Stream.iterate(1, x -> x + 1)
        .limit(5)
        .count());
```

---

### 6ï¸âƒ£ skip()

```java
System.out.println(Stream.iterate(1, x -> x + 1)
        .skip(5)
        .limit(5)
        .count());
```

---

### 7ï¸âƒ£ peek()

> Performs an action **while elements flow through the stream** (mainly for debugging)

```java
Stream.iterate(1, x -> x + 1)
        .skip(10)
        .limit(100)
        .peek(System.out::println)
        .count();
```

---

### 8ï¸âƒ£ flatMap()

> Used to **flatten nested structures** and process them as a single stream

```java
List<List<String>> listOfLists = Arrays.asList(
    Arrays.asList("apple","banana"),
    Arrays.asList("orange","kiwi"),
    Arrays.asList("pear","grape")
);

System.out.println(listOfLists.get(1).get(1));

System.out.println(
    listOfLists.stream()
        .flatMap(x -> x.stream())
        .map(String::toUpperCase)
        .toList()
);
```

### flatMap with Strings

```java
List<String> sentences = Arrays.asList(
    "Hello World",
    "Java streams are powerful",
    "flatMap is useful"
);

System.out.println(
    sentences.stream()
        .flatMap(sentence -> Arrays.stream(sentence.split(" ")))
        .map(String::toUpperCase)
        .toList()
);
```

---

## ğŸ§¨ Terminal Operations

> Terminal operations **trigger execution** of the stream

```java
List<Integer> list = Arrays.asList(1,2,3);
```

---

### 1ï¸âƒ£ collect()

```java
list.stream().skip(1).collect(Collectors.toList());
list.stream().skip(1).toList();
```

---

### 2ï¸âƒ£ forEach()

```java
list.stream().forEach(x -> System.out.println(x));
```

---

### 3ï¸âƒ£ reduce()

> Combines elements into a single result

```java
Optional<Integer> optionalInteger = list.stream()
        .reduce(Integer::sum);
System.out.println(optionalInteger.get());
```

---

### 4ï¸âƒ£ count()

> Counts elements in the stream

---

### 5ï¸âƒ£ Matching Operations

```java
boolean b = list.stream().anyMatch(x -> x % 2 == 0);
boolean b1 = list.stream().allMatch(x -> x > 0);
boolean b3 = list.stream().noneMatch(x -> x < 0);
```

âœ” **Shortâ€‘circuit operations** â€“ stop as soon as condition is met

---

### 6ï¸âƒ£ findFirst() / findAny()

```java
System.out.println(list.stream().findFirst().get());
System.out.println(list.stream().findAny().get());
```

---

### 7ï¸âƒ£ toArray()

```java
Object[] array = Stream.of(1,2,3).toArray();
```

---

### 8ï¸âƒ£ min() / max()

```java
System.out.println("Max: " + Stream.of(2,44,69)
        .max(Comparator.naturalOrder()).get());

System.out.println("Min: " + Stream.of(2,44,69)
        .min(Comparator.naturalOrder()));
```

---

### 9ï¸âƒ£ forEach vs forEachOrdered (Parallel Streams)

```java
List<Integer> numbers0 = Arrays.asList(1,2,3,4,5,6,7,8,9,10);

numbers0.parallelStream().forEach(System.out::println);

numbers0.parallelStream().forEachOrdered(System.out::println);
```

---

## ğŸ§ª Practical Examples

### Filter by Length

```java
names.stream()
     .filter(x -> x.length() > 3)
     .forEach(System.out::println);
```

### Square & Sort

```java
List<Integer> numbers = Arrays.asList(5,2,9,1,6);
System.out.println(numbers.stream()
        .map(x -> x * x)
        .sorted()
        .toList());
```

### Sum Values

```java
System.out.println(integers.stream()
        .reduce(Integer::sum).get());
```

### Count Character Occurrence

```java
String sentence = "Hello world";
System.out.println(sentence.chars()
        .filter(x -> x == 'l')
        .count());
```

---

## ğŸ§  Stateful vs Stateless Operations

| Type      | Description                     | Examples         |
| --------- | ------------------------------- | ---------------- |
| Stateless | No memory of previous elements  | map, filter      |
| Stateful  | Needs to remember past elements | distinct, sorted |

---

## âš  Stream Reuse Limitation

> A stream **cannot be reused** after a terminal operation

```java
Stream<String> stream = names.stream();
stream.forEach(System.out::println);
// stream.map(String::toUpperCase); âŒ Exception
```

---

## ğŸ’¤ Lazy Evaluation Demo

```java
List<String> names = Arrays.asList("Alice","Bob","Charlie","David");

Stream<String> stream = names.stream().filter(name -> {
    System.out.println("Filtering : " + name);
    return name.length() > 3;
});

System.out.println("Before terminal operation");

List<String> result = stream.collect(Collectors.toList());
System.out.println(result);
```

âœ” Filtering happens **only after** terminal operation

---

## ğŸ¯ Key Takeaways

* Streams are **lazy**
* Terminal operations trigger execution
* Intermediate operations build the pipeline
* Streams improve readability & performance
* Streams **cannot be reused**


