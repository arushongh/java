# ðŸ§º Collectors 

## ðŸ§  What is `collect()`?

Think of streams like a **factory conveyor belt** ðŸ­

```
Stream data  â”€â”€â–¶  Collector  â”€â”€â–¶  Final Result
```

* Stream produces elements one-by-one
* Collector decides **how to accumulate** them
* Result can be a `List`, `Set`, `Map`, `String`, `Statistics`, etc.

---

## ðŸŒŸ What is `Collectors`?

> `Collectors` is a **utility class** that provides **ready-made strategies** for collecting stream elements.

### Why use Collectors?

âœ” Avoid manual loops
âœ” Write declarative code
âœ” Perform grouping, partitioning, aggregation easily

ðŸ“Œ **Collectors are used ONLY with `collect()`** (terminal operation)

---

## ðŸ“¦ COMPLETE SOURCE CODE


```java
import java.util.*;
import java.util.stream.Collector;
import java.util.stream.Collectors;

public class CollectorsDemo {
    public static void main(String[] args) {
        /**
         * Collectors is a utility class
         * Provides a set of methods to create a common collectors
         */
        List<String> names = Arrays.asList("Alice","Bob","Charlie");
        // 1. Collecting to a list
        List<String> res=names.stream()
                .filter(name->name.startsWith("A"))
                .collect(Collectors.toList());
        System.out.println(res);

        //2. Collecting to a set
        List<Integer> nums =Arrays.asList(1,2,2,3,4,5,5);
        Set<Integer>set = nums.stream().collect(Collectors.toSet());
        System.out.println(set);

        //3. Collecting to a specific Collection
        ArrayDeque<String> collect =names.stream().collect(Collectors.toCollection(()->new ArrayDeque<>()));

        //4. Joining Strings
        // concatenates stream elements into a single string
        String concatenatedString= names.stream().map(String::toUpperCase).collect(Collectors.joining(", "));
        System.out.println(concatenatedString);

        //5. Summarizing Data
        //Generates statistical summary (Count, sum, min, average, max)
        List<Integer> numbers = Arrays.asList(2,3,5,7,11);
        IntSummaryStatistics stats=numbers.stream().collect(Collectors.summarizingInt(x->x));

        System.out.println("Count : "+stats.getCount());
        System.out.println("Sum : "+stats.getSum());
        System.out.println("Min : "+stats.getMin());
        System.out.println("Max : "+stats.getMax());
        System.out.println("Average : "+stats.getAverage());
        
        //6 . calculating averages
        Double average = numbers.stream().collect(Collectors.averagingInt(x->x)); 
        System.out.println("Average : "+average);

        //7. Counting Elements
        Long count = numbers.stream().collect(Collectors.counting()); 
        System.out.println("Average : "+count);

        // 8. Grouping Elements
        List<String> words =Arrays.asList("hello","world","java","streams","collecting");
        System.out.println(words.stream().collect(Collectors.groupingBy(x->x.length())));
        System.out.println(words.stream().collect(Collectors.groupingBy(String::length,Collectors.joining(", "))));
        System.out.println(words.stream().collect(Collectors.groupingBy(String::length,Collectors.counting())));
        System.out.println(words.stream().collect(Collectors.groupingBy(String::length,TreeMap::new, Collectors.counting())));


        //9l Partitionning Elements
        // Partitions elements into two groups (true and false) based on a predicate

        System.out.println(words.stream().collect(Collectors.partitioningBy(x->x.length()> 5)));

        // 10. Mapping and collecting
        // Applies a mapping function before collecting

        System.out.println(words.stream().collect(Collectors.mapping(x -> x.toUpperCase(), Collectors.toList())));
        

        /**
         * Example 1: Collecting Names by length
         */
        List<String> l1= Arrays.asList("Anna","Bob","Alexander","Brian","Alice");
        System.out.println(l1.stream().collect(Collectors.groupingBy(String::length)));

        // Example 2 : counting word occurences
        String sentence = "hello world hello java world";
        System.out.println(Arrays.stream(sentence.split(" ")).collect(Collectors.groupingBy(x->x,Collectors.counting())));

        // Example 3: Partitioning even and odd numbers
        List<Integer> l2 = Arrays.asList(1,2,3,4,5,6);
        System.out.println(l2.stream().collect(Collectors.partitioningBy(x->x%2==0)));

        // Example 4: Summing Values in a Map
        Map<String, Integer> items = new HashMap<>();
        items.put("Apple", 10);
        items.put("Banana", 20);
        items.put("Orange", 15);

        System.out.println(items.values().stream().reduce(Integer::sum));

        // or 
        System.out.println(items.values().stream().collect(Collectors.summingInt(x->x)));
        
        // Example 5: Creating a Map from Stream Elements
        List<String> fruits = Arrays.asList("Apple","Banana","Cherry");
        System.out.println(fruits.stream().collect(Collectors.toMap(x->x.toUpperCase(),x->x.length())));
        // ^ to map

        //Example 6: 
        
        List<String> word2=Arrays.asList("apple","banana","apple","orange","banana","apple");
        System.out.println(word2.stream().collect(Collectors.toMap(k->k,v->1,(x,y)->x+y)));

    }
}
```

---

## ðŸŽ¬ Step-by-Step Walkthrough (What to Observe)

### ðŸŸ¢ 1. `toList()` â€“ Filtering & Collecting

ðŸ“Œ **Question**: What happens to elements that donâ€™t match the condition?

âž¡ï¸ They are **dropped**, not stored anywhere.

**Output**

```text
[Alice]
```

---

### ðŸŸ¢ 2. `toSet()` â€“ Removing Duplicates

ðŸ“Œ **Key idea**: Sets **never allow duplicates**

**Output**

```text
[1, 2, 3, 4, 5]
```

---

### ðŸŸ¢ 3. `joining()` â€“ Stream â†’ String

ðŸ“Œ Converts multiple elements into **one single String**

**Output**

```text
ALICE, BOB, CHARLIE
```

---

### ðŸŸ¢ 4. `summarizingInt()` â€“ All Stats at Once

ðŸ“Œ One collector â†’ **5 results**

**Output**

```text
Count : 5
Sum : 28
Min : 2
Max : 11
Average : 5.6
```

---

### ðŸŸ¢ 5. `groupingBy()` â€“ Classification

ðŸ“Œ Think of it as **bucket sorting** ðŸª£

**Output**

```text
{5=[hello, world], 4=[java], 7=[streams], 10=[collecting]}
```

---

### ðŸŸ¢ 6. `partitioningBy()` â€“ Boolean Split

ðŸ“Œ Only **two buckets**: `true` and `false`

**Output**

```text
{false=[hello, world, java], true=[streams, collecting]}
```

---

### ðŸŸ¢ 7. `toMap()` with Merge Function

ðŸ“Œ Required when **duplicate keys exist**

```java
(k, v) -> 1, (x, y) -> x + y
```

**Output**

```text
{banana=2, orange=1, apple=3}
```

---

## ðŸ§  One-Glance Collector Cheat Sheet

| Collector      | What it Does       |
| -------------- | ------------------ |
| toList         | Collect into List  |
| toSet          | Remove duplicates  |
| joining        | Merge into String  |
| groupingBy     | Classification     |
| partitioningBy | True / False split |
| summarizingInt | Full statistics    |
| toMap          | Stream â†’ Map       |

---

## ðŸŽ¯ Gold Nuggets

ðŸ’¡ `groupingBy` â‰  `partitioningBy`
ðŸ’¡ `toMap()` **needs merge function** for duplicates
ðŸ’¡ `Collectors` only work with `collect()`

---

## What is a Custom Collector?

A **Custom Collector** in Java is a way to define *your own logic* for
collecting elements from a Stream into a final result.

Instead of using readyâ€‘made collectors like: - `Collectors.toList()` -
`Collectors.groupingBy()` - `Collectors.averagingInt()`

Creating our custom Collector

``` java
Collector.of(supplier, accumulator, combiner, finisher)
```

This is useful when Java does not provide the exact behaviour you need.

------------------------------------------------------------------------

## Example: Building a Custom Average Collector

We will calculate the **average of numbers manually** using a custom
collector.

### Idea

We store two values: - sum of elements - count of elements

Then in the end:

    average = sum / count

------------------------------------------------------------------------

## Code 

``` java
import java.util.*;
import java.util.stream.*;

public class CustomCollectorExample {

    public static void main(String[] args) {

        List<Integer> list = Arrays.asList(1,2,3,4,5,6);

        Collector<Integer,double[],Double> avgCollector = Collector.of(

                // 1ï¸âƒ£ Supplier â†’ Creates container
                // double[0] = sum
                // double[1] = count
                () -> new double[]{0,0},

                // 2ï¸âƒ£ Accumulator â†’ Adds each element into container
                (arr,num)-> {
                    arr[0] += num;   // add to sum
                    arr[1]++;        // increase count
                },

                // 3ï¸âƒ£ Combiner â†’ Used in parallel streams
                // merges two partial results
                (j1,j2)-> new double[]{j1[0]+j2[0], j1[1]+j2[1]},

                // 4ï¸âƒ£ Finisher â†’ Converts container to final result
                // calculate average
                (x)-> x[0] / x[1]
        );

        Double avg = list.stream().collect(avgCollector);

        System.out.println("Average = " + avg);
    }
}
```

------------------------------------------------------------------------

## How Collector.of Works 

| Part        | Meaning                                   |
|------------|-------------------------------------------|
| Supplier    | Creates an empty box to store data        |
| Accumulator | Puts each stream element into the box     |
| Combiner    | Merges boxes (important for parallel streams) |
| Finisher    | Converts the box into final answer        |

------------------------------------------------------------------------

## Output

    Average = 3.5

------------------------------------------------------------------------
