# âš¡ Parallel Streams

## ğŸŒŸ What is a Parallel Stream?

> A **Parallel Stream** allows Java to process stream elements **using multiple threads simultaneously**.

### Why Parallel Streams?

* Utilizes **multiple CPU cores**
* Faster processing for **large datasets**
* Best for **CPUâ€‘intensive & independent tasks**

âš ï¸ Not always faster â€” small tasks may suffer from overhead.

---

## ğŸ§  How Parallel Streams Work

* Uses **ForkJoinPool (common pool)** internally
* Splits data into chunks
* Processes chunks in parallel
* Merges the result

```
Data â†’ Split â†’ Process (Multiple Threads) â†’ Merge â†’ Result
```

---

## ğŸ“Œ Example 1: Sequential Stream vs Parallel Stream

### ğŸ’» Code

```java
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

public class ParallelStream {
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();
        List<Integer> list = Stream.iterate(1, x -> x + 1)
                                   .limit(20000)
                                   .toList();

        List<Long> factorialList = list.stream()
                                       .map(ParallelStream::factorial)
                                       .toList();

        long endTime = System.currentTimeMillis();
        System.out.println("Using sequential stream " + (endTime - startTime) + " ms");

        startTime = System.currentTimeMillis();
        factorialList = list.parallelStream()
                            .map(ParallelStream::factorial)
                            .toList();

        endTime = System.currentTimeMillis();
        System.out.println("Using Parallel stream " + (endTime - startTime) + " ms");
    }

    private static long factorial(int n) {
        long result = 1;
        for (int i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }
}
```

---

### â–¶ Output (Sample)

> Output may vary based on system CPU cores

```text
Using sequential stream 1450 ms
Using Parallel stream 420 ms
```

âœ” Parallel stream is significantly faster for **CPUâ€‘intensive operations**

---

## ğŸ” Converting Parallel â†’ Sequential

```java
list.parallelStream()
    .map(ParallelStream::factorial)
    .sequential()
    .toList();
```

âœ” `.sequential()` forces single-thread execution

---

## âš ï¸ When Parallel Streams FAIL

Parallel streams **fail badly** when:

* Tasks are **dependent on each other**
* Shared mutable state exists

---

## âŒ Example: Dependent Task (Cumulative Sum)

### ğŸ’» Code

```java
List<Integer> numbers = Arrays.asList(1,2,3,4,5);
AtomicInteger sum = new AtomicInteger(0);

List<Integer> cumulativeSum = numbers.parallelStream()
                                     .map(sum::addAndGet)
                                     .toList();

System.out.println("Expected sum : [1, 3, 6, 10, 15]");
System.out.println("Actual result with parallel stream : " + cumulativeSum);
```

---

### â–¶ Output

```text
Expected sum : [1, 3, 6, 10, 15]
Actual result with parallel stream : [3, 1, 10, 6, 15]
```

âŒ Order is incorrect due to **parallel execution**

---

## ğŸ¤” Why AtomicInteger?

```java
AtomicInteger sum = new AtomicInteger(0);
```

* Lambda expressions require **effectively final variables**
* `AtomicInteger` allows mutation safely
* Still âŒ **does NOT fix ordering issues** in parallel streams

---

## âœ… When to Use Parallel Streams

âœ” CPUâ€‘intensive tasks
âœ” Large datasets
âœ” Independent operations
âœ” No shared mutable state

---

## âŒ When NOT to Use Parallel Streams

âŒ I/O operations
âŒ Small datasets
âŒ Dependent calculations
âŒ Shared mutable variables

---

## ğŸ§  Key Takeaways

* Parallel streams use **multiple threads**
* Faster â‰  always better
* Ordering is **NOT guaranteed**
* Avoid shared state
* Use only when task is **independent**

